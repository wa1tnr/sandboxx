/* feed_code-bb.ino */
/* Wednesday 29 Dec 04:32z */

/*  pvwi */

// for wokwi Uno simulator:

//    [ https://wokwi.com/arduino/new?template=arduino-uno ]

/* volatile static int - hard to miss it in a dump */

/* ************************    ADDRESSES    *********************** */
// ram address:
// #define START_ADDRESS 0x200003BA

// internal flashROM address:
// #define START_ADDRESS 0x1d20

#define START_ADDRESS 0xF7FF+1+800+400+400+400

// #define START_ADDRESS 0x0

// how much output - in units of 16 byte lines:
#define LINES 0x40

// p is an integer and is assigned a value that is an address:
int p = START_ADDRESS;



/* ********************    C PREPROCESSOR MACRO    ********************** */
#define lcl_printf() \
    buf_ptr = * & buffer; \
    memcpy(buffering, buf_ptr, sizeof buffer); \
    print_buffer();

char buffering[64];

void burgers() {
    char buffer[48];
    char* buf_ptr;
  
    buffer[0] = 'a';
    buffer[1] = 'z';
    buffer[2] = '\000';

    // static int isn't apparent at all.

    // volatile static in seems to have it all.
    // low in the memory map too.

    volatile static uint8_t Memory[] = {

    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,

    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,

    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x3f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,

    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,

    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x3f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,

    /* msg */
    0x20, 0x20, 0xc0, 0xff, 0xee, 0x20, 0x20, 0x20,
    0x20, 0x20, 0xde, 0xad, 0xbe, 0xef, 0x20, 0x20,
    /* msg */

    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 

    };
    printf(Memory[2]);
    // sprintf(buf_ptr, "%X", Memory[16]);
    // lcl_printf();
}

// simple putch() as used in the C language:
void putch(char ch) {
    Serial.print(ch);
}


void print_buffer(void) {
    Serial.print(buffering);
}

void space_it(void) {
      sprintf(buffering, "%c", ' ');
      print_buffer();
}

void newline(void) {
      sprintf(buffering, "%c", '\n');
      print_buffer();
}

void testpa(void) {
      newline();
      space_it();
      
      char buffer[48]; // 32 also 64
      char* buf_ptr;

      buffer[0] = 'a';
      buffer[1] = 'b';
      buffer[2] = 'c';
      buffer[3] = '\000';

      buf_ptr = buffer;

      int buf_size, buf_ptr_size;

      buf_size = sizeof(buffer); // captures "abc\000" size
      buf_ptr_size = sizeof(buf_ptr);

      int buf_len = strlen(buffer);

      // size_t gottem;

      sprintf(buffering, "%c", '\'');
      print_buffer();

      memcpy(buffering, buf_ptr, sizeof buffer);
      print_buffer();

      sprintf(buffering, "%c%c", '\'', ' ');
      print_buffer();

      sprintf(buffering, "%s ", " is the buffer contents");
      print_buffer();

      sprintf(buf_ptr, "\n         sizeof(buf_ptr) is  %d", buf_ptr_size);

      lcl_printf();

      sprintf(buf_ptr, "%s", "\n         sizeof(buffer)  is ");

      lcl_printf();

      buf_size = sizeof(buffer); // captures "abc\000" size

      sprintf(buf_ptr, "%d\n", buf_size); // related to string length, possibly
      lcl_printf();

      sprintf(buf_ptr, "%s", "         strlen(buffer)  is ");
      lcl_printf();

      sprintf(buf_ptr, " %d\n", buf_len); // related to string length, possibly
      lcl_printf();

      uint8_t adrs;
      adrs = (uint8_t) & buf_ptr;

      sprintf(buf_ptr, "%s", "adrs (& buf_ptr) in hex is        ");
      lcl_printf();

      // print the buffer's address in ram
      sprintf(buf_ptr, "0x%.8X\n", adrs);
      lcl_printf();

      sprintf(buf_ptr, "%s", "adrs (& buf_ptr) in decimal is  ");
      lcl_printf();

      sprintf(buf_ptr, "%c%.11u\n\n", ' ', adrs);
      lcl_printf();

      burgers();

}

void cpl(int pin) {
    bool state = digitalRead(pin);
    state = !state;
    digitalWrite(pin, state);
}
#define TIME_OUT 21334
void time_out(void) {
  for (volatile int timeout = TIME_OUT; timeout >0; timeout--)
    {}
}



void blink(void) {
    cpl(LED_BUILTIN);
    time_out();
    cpl(LED_BUILTIN);
    for (volatile int iter = 277; iter > 0; iter--)
    { time_out(); }  
}



/* **************************    DUMP    ************************* */
int dump_16_bytes(void) {
    char buffer[48]; // 32 also 64
    char* buf_ptr;
    buffer[0] = 'a';
    buffer[1] = 'b';
    buffer[2] = 'c';
    buffer[3] = '\000';

    buf_ptr = buffer;

    char *ram;
    ram = (char *) p; // not used immediately - see Line 43, below

    sprintf(buf_ptr, "\n%4X: ", p); // print an integer 'p' as a formatted string,
                                   // to a string buffer 'buffer'
    lcl_printf();

    // Serial.print('x'); // was annoying
    Serial.print(' ');
    int count = -1;
    for (int i = 0; i < 16; i++) {
        count++;
        if (i == 8)
            putch('\040'); // extra padding after eighth byte is printed
        if (count > 3) {
            count = (count & 0x03); // pad every four bytes ..
            putch('\040');          // with a space char, 0x20 (octal: \040)
        }
        char c = *ram++;      // c now holds the character stored at address p

                              // see Line 27, above, for initial value of *ram

// ----------------------------------------------------------------------------------------
// Exercise   - modify  *ram  so that it does not increment:
//
//      char c = *ram;        // why are we allowed to use  *ram++  here? What does it do?
// ----------------------------------------------------------------------------------------

        sprintf(buf_ptr, " %02X", (c & 0xff)); // format c as two hexadecimal digits (in ASCII)
        lcl_printf();
        // Serial.print("DebugFOO"); // random foo to prove where/when this gets executed
    }
    ram = (char *) p; // see Line 27 - does the exact same thing, but in the present context

    putch('\040'); putch('\040'); putch('\040'); // three spaces

    // print out the ASCII equivalents, in the rightmost 16 columns:
    for (int i = 0; i < 16; i++) {
        buffer[0] = (uint32_t) * ram++;
        if (buffer[0] > 0x7e || buffer[0] < ' ')
            buffer[0] = (uint32_t) '.'; // use a dot for non-printing characters
        buffer[1] = '\0';
        buf_ptr = 
        lcl_printf();
    }
    // increment address in memory by 16:
    return p + 16;
}


void setup (void) {
    pinMode(LED_BUILTIN, 1);
    Serial.begin(115200);
//  while (!Serial) { } // await a connection
    delay(2000); // after connect, wait 2 sec
    Serial.println("here is.");

    testpa();

    delay(6000);      
        for (int index = LINES; index > 0; index--) { // dump three lines 16 bytes/line
        // p has an initial value the first time through this loop
        // p is an address in RAM or ROM
        p = dump_16_bytes();
    }
}

void loop (void) {
    digitalWrite(LED_BUILTIN, 0); // determinate
    while (-1) { blink();}
    Serial.println("Escaped the while()\r\n");
}

/* 29 Dec 03:59z BINGO */
// END.
